# simple_pipeline について

今まで作った部品をパイプライン処理っぽくつなげてみました

5/10
色々変更してたらテスト通ったので置いておきます。可能な限り変更点思い出してここに書いておきます。ただ、コードが色々汚い部分あるのでわかりにくかったら申し訳ないです。。。

5/13
warning 数を減らすべく色々いじってみたので、その報告です。
残り 28warnings まで減りました。

- fetch_p1 の 12 行目：program_counter + 1 を program_counter + 16'b0000_0000_0000_0001 に変更
  　（quartus では普通に 1 と書くと 32bit 扱いされるようなので）

- display_for_16bit の ar, br のデフォルト値が定まっておらず latch になっていると言われていたので、
  デフォルト値を適当に定めました。予期されないセレクタ入力が来た場合、「bad0 bad0」と出力されます
  特に意味はない文字列ですが・・・

- processor.v にて、wire [16:0] br_id,br_ex; を wire [15:0] br_id,br_ex;　に変更

* character_display の num 入力を{1'b0,op}から{2'b00,op}に変更

* op_mem_read_mem, op_branch_ex, op_branch_mem, op_branch_wb について、無くても動作するかなーと思ってなくしてみました

## 留意点

### 全体

全体はテスト部分も含めて作っていて、プロセッサ自体は prosessor という名前のファイルにまとめています。

### パイプラインレジスタの導入

if_id,id_ex,ex_mem,mem_wb という名前の verilog ファイルでパイプラインレジスタを作成しました。やってることは単に各フェーズの output reg だった部分を output にして reg への書き込みをこれらのファイルで行っているだけです。なので特に意味は無いですが、個人的に見やすかったのとストール処理やフラッシュ処理がしやすいかなと思ったのでちょっと分けてみました。正直あんま変える必要なかったかもです。

### 制御線名の変更

op*●●_23 などの数字がはじめわからず(理解不足でごめん、名前変更途中に気づきました)、制御線の名前を
op*●●_ex というように使用されているフェーズ名で表現してます。これも名前変えただけで特に意味なかった気がします。あと is_branched は op_branch、op_stall_data は op_if_id_write や op_id_ex_write に変えています。

### register_file の作成

decode2 の中身が複雑になってきたので register_file という名前のモジュール作成しました。中身はほぼ変更なしですが、レジスタ読み出しをマルチプレクサ(mux8)で行っている点とレジスタ書き込みをクロックの立ち下がり（正確には逆位相クロックの立ち上がり）で行うようにしている点がちょっとした変更です。

### fetch_p1 と instruction_memory

パイプラインレジスタを作成したのにともなって instruction_register 関連の処理は if_id 内で行っています。fetch_p1 内では program_counter のみレジスタを用意して処理を行っています。op_stall_data という信号線は if_id の入力 op_if_id_write で代替してます。

### decode_p2

decode_p2 内に control_unit,hazard_unit,regsiter_file をまとめました。各モジュールの詳細は下に書きます。branch_address の計算時、即値が 0 拡張になっていたので符号拡張に直しました。

### control_unit

新しく op_halt という制御線を追加しました。名前の通り halt 命令のとき 1 になるやつです。

### forwarding_unit

フォワーディングを行うためのモジュールです。
~~計算機アーキテクチャの授業資料の、「フォワーディング改良版」ってところを参考に作成しました。~~
パタヘネの p307 の図を参考に作成しました(p3 に置いてあるイメージです)。
まず p4 と p5 にいる rs,rd,op_reg_write_address の値からそれぞれの書き込み先のレジスタ rt_mem と rt_wb を決定しています。次に関数で op_forward_a,op_forward_b,op_forward_c の値を決定しています(作成してもらった関数を少しいじりました)。ここで op_forward_a は alu_src_a,op_forward_b は alu_src_b,op_forward_c は ar(データメモリへの書き込みデータ)を決定する制御線となっています。これらの制御線を execute_p3 につっこんでます。

### hazard_unit

データハザードによるストールを行うためのモジュールです。
これもパタヘネの p307 の図を参考に作成しました(p2 に置いてあるイメージです)。

・op_halt が 1 のとき
program_counter の更新、if_id レジスタの更新、id_ex レジスタの更新を止めています。
・先のロード命令の格納先を使用するとき
条件は stall_unit のものが 1 フェーズずれているだけで同じだと思います。program_counter の更新、if_id レジスタの更新、id_ex レジスタの更新を止めています。
・条件分岐するとき
ここが少しややこしいです(改善の余地ありです)。まず条件分岐命令のとき(op1==10 かつ即値ロード以外のとき)必ずストールするようにしています。これは 1 つ前の演算結果の cond を格納するためです。次にその値で op_branch を調べたあとその値が 1 なら if_id レジスタをフラッシュして条件分岐するようにしています。このとき 1 度ストールしているかどうかを判定するために内部レジスタ stall を用意しています。これがないとたまたま 2 つ前の cond の値が条件を満たしたときに条件分岐されてしまうので。フラッシュの処理やストールの処理は if_id レジスタ、id_ex レジスタ内で行っています。

### state

~~各モジュールに state 入力を作って、exec による停止を反映しました。
phase_counter がなくなったことによる処置。~~
ややこしくなったので、一旦 state 消しています。あとで exec 反映させればいいかなと思います。

### テスト進捗

サンプルのテストデータは全て通りました(バブルソート・フィボナッチ含め)。
各記憶装置の語数は下記参照

### 主記憶

p1 と p4 によるアクセスの競合を防ぐために、メモリをデータメモリと命令メモリにに分割してある。

instruction_memory : ROM. 命令メモリ、1024 語格納可能
data_memory : RAM. データメモリ。2048 語格納可能

よって、データメモリに与えるアドレスは、元のアドレスから 1024 引いたものとなる。
simple-sample の BubbleSort.txt を見ながら語数決定してます。
